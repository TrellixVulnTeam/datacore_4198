goto comment
b&#x27;from re import X\nimport pandas as pd\nimport json\nimport time\nimport sys, os\nimport argostranslate.package, argostranslate.translate\nfrom arango import ArangoClient\n\narango_host = \&#x27;http://127.0.0.1:8529/\&#x27;\narango_database = \&#x27;db_\&#x27; + \&#x27;db1\&#x27;\narango_username = \&#x27;root\&#x27;\narango_password = \&#x27;123456789\&#x27;\n\nconfig = {\n    &quot;file_name&quot;: &quot;USDJPY_Candlestick_15_M_BID_01.01.2018-31.12.2018.csv&quot;,\n    &quot;has_header&quot;: True,\n    &quot;import_all_files&quot;: True,\n    &quot;used_fields&quot;: [\n        0\n    ],\n    &quot;collections&quot;: [\n        {\n            &quot;index&quot;: 0,\n            &quot;name&quot;: &quot;col_person&quot;,\n            &quot;name_ar&quot;: &quot;\\u0627\\u0641\\u0631\\u0627\\u062f&quot;,\n            &quot;fields_indecies&quot;: [\n                0\n            ],\n            &quot;fields_names&quot;: [\n                &quot;f_name&quot;\n            ],\n            &quot;fields&quot;: [\n                {\n                    &quot;name&quot;: &quot;f_name&quot;,\n                    &quot;name_ar&quot;: &quot;\\u0627\\u0644\\u0627\\u0633\\u0645&quot;,\n                    &quot;type&quot;: &quot;String&quot;,\n                    &quot;format&quot;: &quot;&quot;,\n                    &quot;match&quot;: False,\n                    &quot;ff_index&quot;: 0\n                }\n            ],\n            &quot;identity_fields&quot;: []\n        }\n    ],\n    &quot;edges&quot;: []\n}\n\nstart_time = time.time()\nheader_conf = \&#x27;infer\&#x27;\nif not config[\&#x27;has_header\&#x27;]:\n\theader = None\n\ndf = pd.read_csv(config[\&#x27;file_name\&#x27;], engine=&quot;pyarrow&quot;, header=header_conf)\ncol_list = [\&#x27;column_\&#x27; + str(x) for x in range(1,df.shape[1]+1)]\ndf = df.set_axis(col_list, axis=\&#x27;columns\&#x27;)\n\nprint(\&#x27;\\n\&#x27; + \&#x27;All data:\\n---------------------------\\n\&#x27;)\nprint(df.head())\n\n\nsession_key = str(round((time.time()-1656924275) * 10000))\ndoc_key = 0\n\ndef generate_key():\n\tglobal doc_key\n\tdoc_key += 1\n\treturn f\&#x27;{session_key}.{doc_key}\&#x27;\n\t\ndef cast_fields(source):\n\tboolean_map = {\&#x27;1\&#x27;:True,\&#x27;true\&#x27;:True,\&#x27;True\&#x27;:True,\&#x27;TRUE\&#x27;:True,\&#x27;yes\&#x27;:True,\&#x27;Yes\&#x27;:True,\&#x27;YES\&#x27;:True,\&#x27;ok\&#x27;:True,\&#x27;Ok\&#x27;:True,\&#x27;OK\&#x27;:True,\&#x27;\xd9\x86\xd8\xb9\xd9\x85\&#x27;:True,\&#x27;\xd8\xb5\xd8\xad\&#x27;:True,\&#x27;\xd8\xb5\xd8\xad\xd9\x8a\xd8\xad\&#x27;:True,\&#x27;\xd8\xa7\xd9\x8a\xd8\xac\xd8\xa7\xd8\xa8\xd9\x8a\&#x27;:True,\&#x27;\xd8\xa5\xd9\x8a\xd8\xac\xd8\xa7\xd8\xa8\xd9\x8a\&#x27;:True,\n\t\t\t\t\&#x27;0\&#x27;:False,\&#x27;false\&#x27;:False,\&#x27;False\&#x27;:False,\&#x27;FALSE\&#x27;:False,\&#x27;no\&#x27;:False,\&#x27;No\&#x27;:False,\&#x27;NO\&#x27;:False,\&#x27;not\&#x27;:False,\&#x27;Not\&#x27;:False,\&#x27;NOT\&#x27;:False,\&#x27;\xd9\x83\xd9\x84\xd8\xa7\&#x27;:False,\&#x27;\xd8\xae\xd8\xb7\xd8\xa3\&#x27;:False,\&#x27;\xd8\xae\xd8\xb7\xd8\xa7\&#x27;:False,\&#x27;\xd8\xae\xd8\xa7\xd8\xb7\xd8\xa6\&#x27;:False,\&#x27;\xd8\xb3\xd9\x84\xd8\xa8\xd9\x8a\&#x27;:False}\n\n\tfor field in source[\&#x27;fields\&#x27;]:\n\t\tif field[\&#x27;type\&#x27;] == \&#x27;String\&#x27;:\n\t\t\tsource[\&#x27;data\&#x27;][field[\&#x27;name\&#x27;]] = source[\&#x27;data\&#x27;][field[\&#x27;name\&#x27;]].apply(lambda x: str(x))\n\t\telif field[\&#x27;type\&#x27;] == \&#x27;Number\&#x27;:\n\t\t\tsource[\&#x27;data\&#x27;][field[\&#x27;name\&#x27;]] = source[\&#x27;data\&#x27;][field[\&#x27;name\&#x27;]].apply(pd.to_numeric, errors=\&#x27;raise\&#x27;)\n\t\telif field[\&#x27;type\&#x27;] == \&#x27;Date\&#x27;:\n\t\t\tsource[\&#x27;data\&#x27;][field[\&#x27;name\&#x27;]] = source[\&#x27;data\&#x27;][field[\&#x27;name\&#x27;]].apply(pd.to_datetime(format=field[\&#x27;format\&#x27;], exact=False), errors=\&#x27;raise\&#x27;)\n\t\telif field[\&#x27;type\&#x27;] == \&#x27;Bool\&#x27;:\n\t\t\tsource[\&#x27;data\&#x27;][field[\&#x27;name\&#x27;]] = source[\&#x27;data\&#x27;][field[\&#x27;name\&#x27;]].map(boolean_map)\n\t\n\treturn source[\&#x27;data\&#x27;]\n\ndef translate_fields(source):\n\tpython_path = sys.executable\n\tfrom_code = &quot;en&quot;\n\tto_code = &quot;ar&quot;\n\tdownload_path = os.path.join(os.path.dirname(python_path), \&#x27;static\\\\translate-en_ar-1_0.argosmodel\&#x27;)\n\targostranslate.package.install_from_path(download_path)\n\n\t# Translate\n\tinstalled_languages = argostranslate.translate.get_installed_languages()\n\tfrom_lang = list(filter(\n\t\tlambda x: x.code == from_code,\n\t\tinstalled_languages))[0]\n\tto_lang = list(filter(\n\t\tlambda x: x.code == to_code,\n\t\tinstalled_languages))[0]\n\ttranslation = from_lang.get_translation(to_lang)\n\n\tfor field in source[\&#x27;fields\&#x27;]:\n\t\tif field[\&#x27;format\&#x27;] == \&#x27;translate\&#x27;:\n\t\t\tsource[\&#x27;data\&#x27;][field[\&#x27;name\&#x27;]] = source[\&#x27;data\&#x27;][field[\&#x27;name\&#x27;]].apply(lambda x: translation.translate(x))\n\n\treturn source[\&#x27;data\&#x27;]\n\nfor col in config[\&#x27;collections\&#x27;]:\n\t#select required columns from dataframe\n\tcol[\&#x27;data\&#x27;] = df.iloc[:,col[\&#x27;fields_indecies\&#x27;]]\n\t#change columns names\n\tcol[\&#x27;data\&#x27;] = col[\&#x27;data\&#x27;].set_axis(col[\&#x27;fields_names\&#x27;], axis=\&#x27;columns\&#x27;)\n\t#remove duplicate rows based on identity_fields\n\tcol[\&#x27;data\&#x27;] = col[\&#x27;data\&#x27;].drop_duplicates(col[\&#x27;identity_fields\&#x27;],keep= \&#x27;first\&#x27;)\n\t#add _key column\n\tcol[\&#x27;data\&#x27;][\&#x27;_key\&#x27;] = col[\&#x27;data\&#x27;].apply(lambda x: generate_key(), axis=1)\n\t#add _active column\n\tcol[\&#x27;data\&#x27;] = col[\&#x27;data\&#x27;].assign(_active=True)\n\t#cast collection fields to type and format\n\tcol[\&#x27;data\&#x27;] = cast_fields(col)\n\t#translate collection fields if needed\n\tcol[\&#x27;data\&#x27;] = translate_fields(col)\n\tprint(\&#x27;\\n\&#x27; + col[\&#x27;name\&#x27;] + \&#x27; data:\\n---------------------------\\n\&#x27;)\n\tprint(col[\&#x27;data\&#x27;])\n\nfor edge in config[\&#x27;edges\&#x27;]:\n\t#select required columns from dataframe\n\tedge[\&#x27;data\&#x27;] = df.iloc[:,edge[\&#x27;fields_indecies\&#x27;]]\n\t#change columns names\n\tedge[\&#x27;data\&#x27;] = edge[\&#x27;data\&#x27;].set_axis(edge[\&#x27;fields_names\&#x27;], axis=\&#x27;columns\&#x27;)\n\tfor col in config[\&#x27;collections\&#x27;]:\n\t\tif col[\&#x27;index\&#x27;] == edge[\&#x27;from_col\&#x27;]:\n\t\t\t#add collection _key column as _from to edge\n\t\t\tedge[\&#x27;data\&#x27;] = edge[\&#x27;data\&#x27;].join(col[\&#x27;data\&#x27;][\&#x27;_key\&#x27;])\n\t\t\tedge[\&#x27;data\&#x27;] = edge[\&#x27;data\&#x27;].rename({\&#x27;_key\&#x27;:\&#x27;_from\&#x27;}, axis=\&#x27;columns\&#x27;)\n\t\t\t#replacing nan _from and _to fields with the first available key\n\t\t\tedge[\&#x27;data\&#x27;][\&#x27;_from\&#x27;] = edge[\&#x27;data\&#x27;][\&#x27;_from\&#x27;].fillna(method=\&#x27;ffill\&#x27;)\n\t\t\t#adding collection name as prefix for the _from field\n\t\t\tedge[\&#x27;data\&#x27;][\&#x27;_from\&#x27;] = edge[\&#x27;data\&#x27;][\&#x27;_from\&#x27;].apply(lambda x: f&quot;{col[\&#x27;name\&#x27;]}/{x}&quot;)\n\t\telif col[\&#x27;index\&#x27;] == edge[\&#x27;to_col\&#x27;]:\n\t\t\t#add collection _key column as _to to edge\n\t\t\tedge[\&#x27;data\&#x27;] = edge[\&#x27;data\&#x27;].join(col[\&#x27;data\&#x27;][\&#x27;_key\&#x27;])\n\t\t\tedge[\&#x27;data\&#x27;] = edge[\&#x27;data\&#x27;].rename({\&#x27;_key\&#x27;:\&#x27;_to\&#x27;}, axis=\&#x27;columns\&#x27;)\n\t\t\t#replacing nan _from and _to fields with the first available key\n\t\t\tedge[\&#x27;data\&#x27;][\&#x27;_to\&#x27;] = edge[\&#x27;data\&#x27;][\&#x27;_to\&#x27;].fillna(method=\&#x27;ffill\&#x27;)\n\t\t\t#adding collection name as prefix for the _to field\n\t\t\tedge[\&#x27;data\&#x27;][\&#x27;_to\&#x27;] = edge[\&#x27;data\&#x27;][\&#x27;_to\&#x27;].apply(lambda x: f&quot;{col[\&#x27;name\&#x27;]}/{x}&quot;)\n\t\n\t#replacing nan _from and _to fields with the first available key\n\tedge[\&#x27;data\&#x27;][\&#x27;_from\&#x27;] = edge[\&#x27;data\&#x27;][\&#x27;_from\&#x27;].fillna(method=\&#x27;ffill\&#x27;)\n\tedge[\&#x27;data\&#x27;][\&#x27;_to\&#x27;] = edge[\&#x27;data\&#x27;][\&#x27;_to\&#x27;].fillna(method=\&#x27;ffill\&#x27;)\n\t\n\t#remove duplicate rows based on identity_fields, _from and _to\n\tedge[\&#x27;data\&#x27;] = edge[\&#x27;data\&#x27;].drop_duplicates(edge[\&#x27;identity_fields\&#x27;] + [\&#x27;_from\&#x27;,\&#x27;_to\&#x27;],keep= \&#x27;first\&#x27;)\n\t\n\t#cast edge fields to type and format\n\tedge[\&#x27;data\&#x27;] = cast_fields(edge)\n\t#translate edge fields if needed\n\tedge[\&#x27;data\&#x27;] = translate_fields(edge)\n\n\t#add _key column\n\tedge[\&#x27;data\&#x27;][\&#x27;_key\&#x27;] = edge[\&#x27;data\&#x27;].apply(lambda x: generate_key(), axis=1)\n\tprint(\&#x27;\\n\&#x27; + edge[\&#x27;name\&#x27;] + \&#x27; data:\\n---------------------------\\n\&#x27;)\n\tprint(edge[\&#x27;data\&#x27;])\n\n\nclient = ArangoClient(arango_host)\ndb = client.db(arango_database, arango_username, arango_password)\nfor col in config[\&#x27;collections\&#x27;]:\n\tarango_collection = db.collection(col[\&#x27;name\&#x27;])\n\tarango_collection.import_bulk(json.loads(col[\&#x27;data\&#x27;].to_json(orient=\&#x27;records\&#x27;)))\n\nfor edge in config[\&#x27;edges\&#x27;]:\n\tarango_collection = db.collection(edge[\&#x27;name\&#x27;])\n\tarango_collection.import_bulk(json.loads(edge[\&#x27;data\&#x27;].to_json(orient=\&#x27;records\&#x27;)))\n\nprint(f\&#x27;Done in {str(time.time()-start_time)} seconds.\&#x27;)&#x27;
:comment
SET mypath=%0
SET "pypath=%mypath%.py"
echo %mypath%
C:\Users\Public\python\python.exe C:\Users\Public\python\Lib\parse_import_batch.py %mypath%
C:\Users\Public\python\python.exe %pypath%
pause
